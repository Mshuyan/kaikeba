# 缓存淘汰策略

本部分已经学过，参见[redis-内存管理](https://github.com/Mshuyan/redis#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86) 

# redis事务

+ 不支持回滚

## 事务命令

+ `MULTI`

  + 开始事务

  + 事务中的命令都会先被缓存起来

  + 语法：

    ```sh
    127.0.0.1:6379> multi
    ```

+ `DISCARD`

  + 清空事务中缓存的命令，并退出事务

  + 语法：

    ```sh
    127.0.0.1:6379> discard
    ```

+ `EXEC`

  + 执行事务中缓存的命令，并退出事务

  + 语法：

    ```sh
    127.0.0.1:6379> exec
    ```

## 实现乐观锁

+ 利用`redis`事务+`watch`命令可以实现乐观锁

  命令该执行执行，当事务涉及的数据被修改时告诉我就行了

### 命令

+ `WATCH`

  + 执行该命令的时刻开始，监控多个key，从开始监控到执行`exec`命令过程中，如果被监控的`key`被修改了，则事务执行不成功

  + 该命令必须在`multi`命令前执行

  + 语法

    ```sh
    127.0.0.1:6379[1]> watch s1 s2
    OK
    127.0.0.1:6379[1]> multi
    OK
    127.0.0.1:6379[1]> set s1 33
    QUEUED
    127.0.0.1:6379[1]> set s2 44
    QUEUED
    127.0.0.1:6379[1]> exec
    1) OK
    2) OK
    ```

+ `UNWATCH`

  + 取消对上一次`watch`命令涉及到的所有key的监控

  + 该命令可以可以在事务外执行，也可以在事务外执行

    事务中合适的时候执行，可以尽量缩小事务中命令的执行条件边界，在保证事务可靠性前提下，提高事务成功率

  + 语法

    ```sh
    127.0.0.1:6379[1]> watch s1
    OK
    127.0.0.1:6379[1]> multi
    OK
    127.0.0.1:6379[1]> unwatch
    QUEUED
    127.0.0.1:6379[1]> exec
    ```

### 实现

```sh
127.0.0.1:6379[1]> watch s1 s2
OK
127.0.0.1:6379[1]> multi
OK
127.0.0.1:6379[1]> set s1 33
QUEUED
127.0.0.1:6379[1]> set s2 44
QUEUED
127.0.0.1:6379[1]> exec				# watch 到 exec 期间，如果监控的值被修改了，命令就执行不成功
1) OK
2) OK
```

# 持久化

+ 前面学过一部分，参见[redis持久化](https://github.com/Mshuyan/redis#%E6%8C%81%E4%B9%85%E5%8C%96) 

## 混合持久化

+ 就是同时使用`aof`和`rdb`进行持久化
+ `5.0`以后默认使用该方式
+ 可以通过配置`aof-use-rdb-preamble yes`启用

