> `TODO`
>
> + 隔离级别是使用锁解决的吗？还是分离出独立缓存？都有那些锁？
> + 幻读包括删除操作吗？可重复读使用的锁（行锁？）能否阻止删除？
> + 什么时候使用LBCC和MVCC
> + 串行化时，select还需要显示上锁吗
> + 锁，
>   + https://www.cnblogs.com/rjzheng/p/9950951.html
>   + https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html#innodb-intention-locks

# 事务执行流程

![image-20201117160501379](assets/image-20201117160501379.png) 

# 事务介绍

## 事务特性（ACID）

+ 原子性（`atomicty`）

  整个事务要么全成功。要么全失败

+ 一致性（`consistency`）

  事务开始前和结束后，数据完整性不要被破坏（因为事务部分提交导致出现错误数据）

+ 隔离性（`isolation`）

  不同事务之间不能相互影响

  隔离性的强弱与事务的性能相关，隔离级别越高性能越差

+ 持久性（`durability`）

  事务提交后数据永久有效

## 隔离级别

### 事务之间存在哪些影响

+ 脏读

  一个事务读取到另一个事务中还`未提交`的数据

+ 不可重复读

  因其他事务提交的`修改和删除`，一个事务中两次读取同一条数据的结果不一致

+ 幻读

  因其他事务提交的`新增`，一个事务中两次读取到的数据不一致

+ 丢失更新

  两个事务同时执行时，后提交事务`覆盖`了先提交的事务提交的数据

### 隔离级别

+ 读未提交（RU）

  未解决任何问题

+ 读已提交（RC）

  解决脏读

  `oracle`默认

+ 可重复读（RR）

  解决脏读、不可重复读

  `mysql`默认

+ 串行化（`Serializable`）

  解决所有问题

# 事务实现方案

## 术语

+ 快照读

  + 不加锁的`select`就是快照读
  + 读取到的是当前事务的可见版本数据

+ 当前读

  + 读取数据同时加上共享锁或排他锁

  + 读取到的一定是最新版本数据

    这里不用解释为：最新版本`已提交`数据；因为未提交的数据上了排他锁，压根读不到

  + 哪些操作使用当前读

    + `select`+共享锁

      ```sql
      # 所有版本
      select * from test lock in share mode
      # 8.0
      select * from test for share
      ```

    + `select`+排他锁

      ```sql
      select * from test lock in share mode
      ```

    + `insert`、`update`、`delete`操作中都隐式包含了一步当前读

## 概述

+ `InnoDB`使用`LBCC`+ `MVCC`实现的事务

  所有`insert`、`update`、`delete`操作自动使用排他锁

  + RU

    + `LBCC`方案，`select`不加锁
    + 读写同一份数据，因为写操作使用排他锁，写与写串行执行

  + RC

    `LBCC`+`MVCC`方案，

    + `select`不加锁
    + 每次读取都使用最新的`read view`

  + RR

    `LBCC`+`MVCC`方案，

    + `select`不加锁
    + 第一次读取时将`read view`缓存起来，后续读取时使用缓存的`read view`

  + `Serializable`

    `LBCC`方案，`select`自动加上`意向共享锁`

+ 模型

  

## LBCC

+ 基于锁的并发控制（`Lock Based Concurrency Control`）

### 锁



### 总结

+ 因为写操作一定使用排他锁，所以只要数据被锁上了，就不能写了，所以只需要一份数据即可，不需要`MVCC`中那么多份快照数据

+ 写操作都有排他锁，所以不存在丢失更新的问题

+ 性能

  + 写操作一定使用排他锁，所以写操作一定是串行执行的

  + 读

    + 当`select`不加锁时

      + 因为只有一份数据，事务中对数据的修改一定直接在这份数据上修改，其他事务就可以读到未提交的数据，脏读、不可重复读、幻读、丢失更新等问题都出现了，**这就是RU的实现原理**
      + 并行：读读、读写、写读
      + 串行：写写

    + 当`select`加`意向共享锁`时

      + 可以避免哪些问题
        + 脏读：事务在修改数据的过程中，不允许其他事务来读，从根本上避免了脏读
        + 幻读：范围查询时会使用`Next-Key Locks`将范围锁住，不允许插入，避免幻读
        + 不可重复读：读的过程中不允许其他事务来写，根本上避免了不可重复读
      + 并行：读读
      + 串行：读写、写读、写写
      + **这就是`Serializable`实现原理**

    + 当`select`加`意向排他锁`时

      相比`select`加`意向共享锁`，读读也变成串行执行，能避免一个事务读取到正准备进行修改的数据

      意义并不大，不建议使用

## MVCC

+ 多版本并发控制（`Multi Version Concurrency Control`）
+ 只能在`读已提交`和`可重复读`两个级别使用
+ 为每个事务中读写的数据行生成独立的快照版数据，读取时只读取自己可见版本数据
+ `InnoDB`中，使用`undo_log`和`read view`实现`MVCC`

### unco_log



### read view



### 流程



### 总结

+ 因为每个事务中读写的数据都有对应的快照版本，其他事务是在他自己的快照中进行读写，当前事务依然可以从自己的快照中读取数据，相互隔离，避免加锁

+ 相比`LBCC`中`select`加`意向共享锁`的方案，提升了读写、写读操作的性能，也可以通过快照的方式解决了不可重复读的问题

+ 但同时引入了另一个问题：

  某字段原本是1，两个事务同时读取并进行加1操作，正确结果应该是3，但是实际结果可能是2

  这个问题只能通过`select`加`意向共享锁`解决



























